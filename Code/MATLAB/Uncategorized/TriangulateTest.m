function worldPoints = TriangulateTest()
%% 
% Try to Estimate the Optimal Transformation Between Reconstructed World 
% Coordinates to Gantry Coordinates


%%
[worldPoints, GantryPos] = loc_Triangulate();

%% Find Rigid Transorm (A => B)
GantryPos = GantryPos * 100; % Gantry Unit: [cm]
worldPoints = worldPoints / 10; % Unit: [cm]

nPoints = size(worldPoints,1);

[regParams,Bfit,ErrorStats] = absor(worldPoints',GantryPos','doScale',1);

Bfit = Bfit';

% Calculate Error
nrmError = zeros(nPoints,1,'double');
for i = 1:nPoints
    nrmError(i) = norm(Bfit(i,:) - GantryPos(i,:));
end

figure;
subplot(1,2,1);
bar(nrmError,'b');
xlabel('Trial #');
ylabel('Reprojection Error [cm]');
title('Reprojection Error Using Optimal Rigid Transformation Method');

%% Bayesian Neural Network Method
BNNfit = TransformANN(worldPoints);

% Calculate Error
nrmError = zeros(nPoints,1,'double');
for i = 1:nPoints
    nrmError(i) = norm(BNNfit(i,:) - GantryPos(i,:));
end

subplot(1,2,2);
bar(nrmError,'b');
xlabel('Trial #');
ylabel('Reprojection Error [cm]');
title('Reprojection Error Using Bayesian Neural Network Method');

%% Re-Center All the Points
% centroidGantry = mean(GantryPos);
% centroidWorld = mean(worldPoints);
% 
% nPoints = size(GantryPos,1);
% 
% GantryRC = GantryPos - repmat(centroidGantry,nPoints,1);
% WorldRC = worldPoints - repmat(centroidWorld,nPoints,1);
% 
% GantryRC = GantryRC';
% WorldRC = WorldRC';

%% Find Rigid Transorm (A => B) such that  B = R * A + t
% H = GantryRC * WorldRC';
% [U,~,V] = svd(H);
% 
% R = V * U'; % Rotation Matrix
% t = -R * centroidGantry' + centroidWorld'; % Translation
% 
% if det(R) < 0
%     fprintf('Reflection detected\n');
%     V(:,3) = -1 * V(:,3);
%     R = V * U';
% end

%% Verify the Accuracy of Recontruction
% G2W = (R * GantryPos') + repmat(t, 1, nPoints);
% G2W = G2W';
% % Find the error
% err = G2W - worldPoints;
% err = err .* err;
% err = sum(err(:));
% rmse = sqrt(err/nPoints);
% fprintf('RMSE: %f\n', rmse);

end

function [worldPoints, GantryPos] = loc_Triangulate()
%% Load Stereo Camera Calibration Data
load('StereoCameraCalibration-2.mat');
load('TestImg-2.mat');

[worldPoints,reprojectionErrors] = triangulate(matchedPt1,matchedPt2,stereoParams);

end

function [y1] = TransformANN(x1)
%TransformANN neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 12-Aug-2016 10:31:40.
%
% [y1] = TransformANN(x1) takes these arguments:
%   x = Qx3 matrix, input #1
% and returns:
%   y = Qx3 matrix, output #1
% where Q is the number of samples.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1_xoffset = [64.901778151504;-8.42209010747119;130.189970511086];
x1_step1_gain = [0.0688013705172384;0.0739789493547617;0.0762121584900576];
x1_step1_ymin = -1;

% Layer 1
b1 = [-0.84478751913874262;0.62482150249037582;-0.52602559945415883;0.68828147510444948;0.024600675497650798;-0.61150543662932011;1.313895903284739;-0.813448568495311;0.48353152862540655;0.90498531476796162];
IW1_1 = [-0.069377505937470413 -0.89823512177588027 0.1414302776648742;-0.50791966375137754 -0.24775682356759371 -0.80759154882098738;0.41185693415873365 1.1710136335736043 0.062110819072594803;-0.14065872031411641 0.3898672182175334 0.68040120193514353;-0.47498540199620642 0.19297477252840467 0.72813483846786575;0.79950541040020062 -0.093888105361827442 -0.24275550970943482;0.15100949436486102 0.14359990046879925 0.91834795483946852;-0.28521039518839691 0.74727578313495679 0.74968548565733151;0.0046000771714671046 -0.52668840487990709 0.30405624168141437;0.88829432357091875 -0.09179920290870007 -0.30574800206221892];

% Layer 2
b2 = [-0.144840488872127;-0.06145617472222413;0.08678889254879403];
LW2_1 = [0.19992335205125222 -0.37203568871179249 -0.21935445913302642 0.034350461740412744 0.19289722676693821 0.7068312076782356 0.53899945663905624 0.29230108927680237 -0.12353016856432146 0.76837062672496514;0.65530480829918658 -0.70933592513563914 -0.44753884551284173 0.48010589363270717 0.0082269378653298531 -0.39900967071607435 0.87753424631223576 0.72758830950238496 -0.03843299260919078 -0.32378714184249729;0.58789335435860646 -0.052579661060709784 -0.18004411261342532 -0.76547639088138475 0.36953411317628748 0.063899351215159605 0.03521047982239086 -0.53987328439718685 0.75025739362135369 0.034834845388113815];

% Output 1
y1_step1_ymin = -1;
y1_step1_gain = [0.0666666666666667;0.1;0.08];
y1_step1_xoffset = [-5;10;-35];

% ===== SIMULATION ========

% Dimensions
Q = size(x1,1); % samples

% Input 1
x1 = x1';
xp1 = mapminmax_apply(x1,x1_step1_gain,x1_step1_xoffset,x1_step1_ymin);

% Layer 1
a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*xp1);

% Layer 2
a2 = repmat(b2,1,Q) + LW2_1*a1;

% Output 1
y1 = mapminmax_reverse(a2,y1_step1_gain,y1_step1_xoffset,y1_step1_ymin);
y1 = y1';
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings_gain,settings_xoffset,settings_ymin)
y = bsxfun(@minus,x,settings_xoffset);
y = bsxfun(@times,y,settings_gain);
y = bsxfun(@plus,y,settings_ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings_gain,settings_xoffset,settings_ymin)
x = bsxfun(@minus,y,settings_ymin);
x = bsxfun(@rdivide,x,settings_gain);
x = bsxfun(@plus,x,settings_xoffset);
end
